### 什么是序列化

序列化和反序列化是一个过程，这个过程其实就是我们给数据加一层标识，告诉虚拟机序列化的时候该怎么给数据加壳，反序列化的时候该怎么将数据的壳去掉，取出其中的数据。
当我需要保存信息到内存中或者文件里的时候，我要对这些信息做一些标记和标准规范。

### Serializable接口

你可以看到Serializable接口是空的！

- 既然是空的，它是怎么做到序列化的呢？

  其实啊，这个接口本身并没有做什么，它在这里只是充当了标记的作用。  
  
  有没有发现，在源码的注释里有ObjectOutputStream、ObjectIntputStream、ObjectOutput、ObjectInput。
这就是说，只要你的类打上了“Serializable”这个标记，就可以使用outputStream这个流把它写出去，如果没有打上这个标记你就去用流写的话，它就会抛出一个异常。


- 那打上这个标记之后，它是如何做到序列化与反序列化的呢？

  这后续的操作就是由JDK自己完成的了。
  
  比如说我现在有一个Student类 要通过io流把它写到文件中去，这个时候我就必须让它实现Serializable接口。
  
  使用之后，当你用流去写的时候，jdk自己就会把这个类中的所有属性（类型/值/名字等所有信息）打包写到一个文件中去。

  这样在以后别人要用它的时候，就能根据标记来恢复，这是一个逆向的过程，所以叫做反序列化。
  
  当然，它底层其实是用的反射，用反射去获取类的属性、名字等等信息。

Java提供的接口，主要用于文件读写和网络传输数据，也可以用于android组件之间传递数据，
只是因为Serializable接口操作数据时候，序列化和反序列化时候，会产生大量的变量，也会有频繁的IO操作，
开销大，导致在组件之间传递数据时候效率低，所以不建议在android组件之间传递数据。

### Parcelable接口

android提供的接口，主要用于不同组件之间传递数据，因为内部实现靠自定义操作，所以相对于Serializable接口来说，
实现比较麻烦，但是给了开发人员高度的自由度，序列化和反序列化时候，不会产生大量的变量，也不会有频繁的IO操作，所以序列化和反序列化时候开销小，效率高。

特别要注意的是：不能用来进行文件操作，否则会报异常。


