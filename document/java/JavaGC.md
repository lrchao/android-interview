### Java GC 的几种算法

1.<b>标记-清除算法</b>

a. 标记阶段：标记的过程就是前面的可达性分析法执行的过程。首先遍历所有 GC Roots 对象，对从 GC Roots 对象可达的对象都打上一个可达标识。这个可达标识一般记录在对象 header 中（一个对象一般包括对象头、实例数据、对齐填充三个部分），表示该对象可以被 GC Roots 访问。   
b. 清除阶段：清除阶段是对堆内存进行遍历，通过读取这些对象的 header 信息来获取对象是否标记可达。如果未标记则表示这些对象没有引用，就可以进行回收。  

效率问题：标记和清除都需要遍历，效率不高；
空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。 

2.<b>复制算法</b>  

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清除掉使用过的这一半。但是代价就是内存利用率太低。  

优点：简答高效，内存相对整齐   
缺点：  
1.将内存分为一半，代价略高。  
2.如果对象存活率高，需要复制的对象比较多，产生效率问题。  

3.<b>标记-整理算法</b>  

标记过程仍然与标记 — 清除算法一样，然后让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域   

优点：无需复制，保证效率。内存规整。   
缺点：效率不如复制算法。   

4.<b>分代收集算法</b>

分代收集算法，是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合  
原理：把 Java 堆分为新生代和老年代，根据各个对象的年代采用最合适的收集算法。   
针对新生代的对象，采取灵活比例的复制算法，只需要复制少量存活对象就可以完成收集。   
针对老年代的对象，因为这些对象存活率高，没有额外空间进行分配担保，必须使用 标记 - 清除 或 标记 - 整理 算法。  

